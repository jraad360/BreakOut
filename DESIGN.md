game - "DESIGN.md"
====

by Jorge Alejandro Raad

### Design Goals
At first, my objective was to add all my planned features, one step at a time. I would add code as I went along without really changing the structure of my code when I would see problems. This is how I made RunGame—one giant class that runs Breakout. I did do a good job of keeping methods short, specialized, and readable (although there are more opportunities to refactor into more methods). I realized once I was close to finishing it that the design was poor, so I decided to rewrite the whole project with multiple classes. I decided to separate into classes that represent the different objects used to create the levels (Bouncer, Item, Block, Paddle). I also created a Level class that contains all the information on the level and updates the positions of all the objects. Finally the main class, RunBreakOut, sets up the stage, scene, animation, checks key and mouse inputs, and controls the switching between levels.

### Adding New Features
#####Levels
* The levels are generated by writing the name of a text file into the Level constructor. The text file should be just be called the number of the level. This is because a specific character is read from the text file and then placed in the status bar that indicates the level number. To implement new levels, the only part of the code that would have to be altered would be within the main Class. The way the game moves on to the next level is by having an if statement for each level. For example:
 ```java
                if (currentLevel.getFileName() == LEVEL1 && currentLevel.getNumberOfBlocks() == 0) {
                    currentLevel = new Level(LEVEL2);
                    myScene.setRoot(currentLevel.getRoot());
                    displayScore();
                    currentLevel.setMainBouncer(myBouncerImage);
                }
```
* To implement another level, I would have to manually add in another if statement after the existing ones.

#####Block
* To add another block, I would have to edit to bits of code. The first is within readInLevel() in the Level Class. Here, I would have to decide on a character that represents the block within the text file. From there, I would add an if statement that places the block down if the character is read in from the text file. Then I would need to edit the updateBlock() method within Level to tell the block how to behave when hit. Within this function, there another series of if statements that decides what to do with the block depending on its type. I would need to add another if statement that identifies the block and tells it and the bouncer what to do when hit.

#####Power-Ups
* A theme you can see here is the use of if statements to determine how the object in question should be handled. This is the case again. To implement another power-up you would have to, once again, add if statements in two parts of the Level class. First in the updateBlock() method. This is where power-ups are created depending on set probabilities. You would create a random number between 0 and 1 and if the number is less than the specified probability, then create it, add its ImageView to the root, and place it in myItems. The other code you would have to edit is in activateItem(). When an item touches the paddle, this is called. Within, there is a series of if statements that compare the object to the different kinds of items and then implements its effects when the item is identified. We would need to add another case here.

*While it is relatively easy to implement these changes (for a new level add 1 if statement, for a block or power-up add 2; in all cases, you can copy & paste and then change a few words), it is very inefficient. Having looked at superclasses, subclasses, and abstractions, It would have been easier to make item and block abstract superclasses. The length of my classes would have been significantly reduced by immediately removing the need for many, many if statements. To implement more levels however, I would not create super/subclasses since that would take away the whole point of the flexibility in reading in the text file. I think what I could do is create a method that creates an array of a specified number of initialized levels. Then, within the Level class, I could create a myNextLevel intense variable. This way I can simply have one if statement that says:
 ```java
                if (currentLevel.getNumberOfBlocks() == 0) {
			currentLevel = currentLevel.myNextLevel;
                }
```


### Design Choices
One major decision I had to make when rewriting the program with multiple classes is whether I wanted the Level or the individual instances (of Blocks, Items, Bouncers, Paddle) to update their own locations and velocities and such or whether the Level should should run these methods itself by passing the objects in as parameters (placeCenterBall(), executePaddleCollision(), executeWallCollision(), executeBlockCollision(), updateBlock(), activateItem(), activateMultiplier()). I decided to have the level implement these methods. The reason I did was because when I decided to try to have the other classes hold these methods, I realized that in some cases I would need to pass in multiple of the Level’s instance variables such as the root, RUN_STATE, poisonTag, myBouncerSpeed, STATUSBAR_HEIGHT and more. Later on, I realized that adding all these parameters to the method would not be necessary, a lot of these variables that are called from within the methods can be moved to the stepThrough() function. In some cases however, I would need to pass in some useful information as instance variables. 

In the end, implementing it how I did was easier but it also had a few other benefits. For example, I avoided needing to add more variables to the specific object classes. I also had all of the physics-related methods all in one place in the Level class. However, implementing it this way resulted in around 200 more lines of code in my level class. In hindsight, I believe the right choice would have been to move these methods and allow each object to control its own physics. One way I could have fixed the problem of passing in information is by having myLevel be an instance variable within the object classes. This way, the object has access to information on the level they are currently in. This way, the only arguments taken by collision methods would just be the one object it is colliding with. The update and activation methods would need no arguments.

### Assumptions or Decisions Made to Simplify or Resolve Ambiguities
One problem I ran into a few times was the transfer of information between Level and RunBreakOut. I tried to make Level as independent as possible so that every time I wanted to update the level from the main class, I would just need to call myCurrentLevel.stepThrough(). However, I found myself needing information such as whether a life was lost and its cause to be transferred from Level to the main class.   I also needed a way of increasing the score. I experimented with passing in the number of lives and the score into Level and allowing it to edit them, but I was discouraged by the rising number of arguments being passed into this stepThrough() method. Finally, while unintuitive, I came up with a system of updating the number of lives and score. I would pass in the score and I would return an int: -2 for death by poison mode, -1 for normal death, and the updated score if a life was not lost.

# Bug Fixes
#####Bouncer Image
* I fixed a line where I meant to change the appearance of the ball when in poison mode. I had accidentally referred to the variable that contained the file name of the bouncer image currently in use. 
* I wrote a public method setMainBouncer() that sets myBouncerImage, which is a simple private String that replaced the final String variable BOUNCER_IMAGE. I replaced the calls to setBouncerImage() within the main class with calls to setMainBouncerImage(). This made it so every bouncer was set to the selected bouncer image instead of just the very first bouncer, which is how it was before.

#####Poison Mode
* There was a bit of code that causes the player to lose a life when hit by the poison mode bouncer. I accidentally put it so it would occur every time the stepThrough() function was called. I simply moved it to the inside of the if statement that checks if the paddle and bouncer have made contact.
* Toggled the floor when poison mode was activated and removed it when poison mode was over with.
Freeze Power-up
* Within Level, when implementing the freeze power-up, I only adjusted the x-velocity, not the y-velocity, and I accidentally caused the freeze power-up to also act like an enlarger power-up so I deleted that line.

#### Additional Bugs
* Bouncer sometimes goes through blocks.
* Bouncer sometimes unpredictable.

                
                